
* Day one
- input:
  + several lines
  + each line has a number or blank
  + blank indicates end of group
- transformation:
  + for each group, calculate sum of numbers in their lines
- first output:
  + max amount in a group
- second output:
  + total of the top 3 groups

#+begin_src clojure
(ns advofcode.dayone
  (:require [clojure.string :as str]))

(defn split-file-into-groups [file-content]
  (->> file-content
       (str/split-lines)
       (partition-by #(= % ""))
       (remove #(= % [""]))
       ))

(defn sum-group [arr-of-strings]
  (->> arr-of-strings
       (map read-string)
       (reduce +)
       ))

(let [file-content  (slurp "data/day-one.txt")
      groups        (split-file-into-groups file-content)
      sums          (map sum-group groups)
      max           (reduce max sums)
      top-three     (->> sums (sort) (reverse) (take 3))
      sum-top-three (reduce + top-three)
      ]
  )
#+end_src

* Day two
- Input:
  + Several lines
  + In each line you have two letters: [A, B, C ] and [X, Y, Z]
  + A=X=rock, B=Y=paper, C=Z=scissor
- First transform:
  + For each line compute score = score_shape + score_win
  + score_shape: A=1, B=2, C=3
  + score_wind: win=6, draw=3, loss=0
  + NOTE: need to handle 2 special cases (A vs. Z and C vs. X)
- Second transform:
  + Now X is loss, Y is draw and Z is win (one part of the score is already calculated)
  + Need to map first column to corresponding shape to get second part of the score
- Outputs:
  + Total score according to first transform
  + Total score according to second transform
  
#+begin_src clojure
(ns advofcode.daytwo
  (:require [clojure.string :as str]))

(defn letter->number [letter]
  (let [conversion {\A 1
                    \B 2
                    \C 3
                    \X 1
                    \Y 2
                    \Z 3}]
    (get conversion letter)))

(defn calculate-match-score [opp me]
  (cond
    (win? opp me)  6
    (draw? opp me) 3
    (loss? opp me) 0
    :else          (throw (AssertionError. "Impossible"))
    ))

(defn opp->number [opp me]
  (let [opp (letter->number opp)
        me  (letter->number me)]
    (if (and (= opp 1) (= me 3))
      (+ 3 opp)
      opp)))

(defn me->number [opp me]
  (let [opp (letter->number opp)
        me  (letter->number me)]
    (if (and (= me 1) (= opp 3))
      (+ 3 me)
      me)))

(defn draw? [opp me]
  (= (opp->number opp me) (me->number opp me)))

(defn win? [opp me]
  (< (opp->number opp me) (me->number opp me)))

(defn loss? [opp me]
  (> (opp->number opp me) (me->number opp me)))

(defn outcome->me [opp outcome]
  ;; X lose, Y draw Z win
  (get [opp outcome]
       {[\A \X] \Z
        [\A \Y] \X
        [\A \Z] \Y
        [\B \X] \X
        [\B \Y] \Y
        [\B \Z] \Z
        [\C \X] \Y
        [\C \Y] \Z
        [\C \Z] \X
        }))

(defn calculate-line-score [line]
  (let [opp         (first line)
        me          (last line)
        outcome     (last line)
        outcome->me (outcome->me opp outcome)
        match-score (calculate-match-score opp me)
        shape-score (letter->number me)
        ]
    (+ match-score shape-score)
    ))

(let [file-content (slurp "data/day-two.txt")
      lines        (->> file-content (str/split-lines))
      lines-score  (->> lines (map calculate-line-score))
       fsjkzz]
  (reduce + lines-score)
  ;; (take 5 lines-score)
  )
#+end_src

* Day three
- Input
  + Multiple lines
  + In every line many letters, lowercase and uppercase
  + Lowercase letters represent item type 1 and uppercase item type 2
  + Each line represents a rucksack
  + First half of line represents first compartment
- First transformation:
  + Map letters to numbers (priority) (a -> 1, ... z -> 26, A -> 27, ... Z -> 52)
  + Find letter present in both compartments and calculate its priority
- Second transformation:
  + Every 3 lines form a group
  + Find item common among the 3 groups
  + Map it to a priority
- Outputs:
  + Sum of priorities over lines
  + Sum of priority over groups
* Day four
- Input
  + Multiple lines
  + Every line indicates two ranges: 2-4,6-8
- Transform:
  + Identify whether one of the two ranges is fully included in the other
- Output
  + Number of lines where the condition is true
